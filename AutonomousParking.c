#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTIRS,          sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     frontRightMotor, tmotorTetrix, openLoop, reversed, driveRight)
#pragma config(Motor,  mtr_S1_C1_2,     frontLeftMotor, tmotorTetrix, openLoop, driveLeft)
#pragma config(Motor,  mtr_S1_C2_1,     backRightMotor, tmotorTetrix, openLoop, reversed, driveRight)
#pragma config(Motor,  mtr_S1_C2_2,     backLeftMotor, tmotorTetrix, openLoop, driveLeft)
#pragma config(Motor,  mtr_S1_C3_1,     centerMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     drawerMotor,   tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    draggerServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    clickerServo,         tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "hitechnic-irseeker-v2.h"

tHTIRS2 irSeeker;

#define wanted_magnitude 10
#define time_constant 5

#define servoPosition1 25
#define servoPosition2 70
#define servoPosition3 150

void ir(int* magnitude, int* direction)
{
	readSensor(&irSeeker);
	*direction = irSeeker.enhDirection;
	*magnitude = irSeeker.enhStrength;
	return;
}

void initializeRobot()
{
	initSensor((tHTIRS2Ptr)irSeeker, (tSensors)S2);
	return;
}

int magnitude_to_time(int magnitude) { //returns time to drive forward based on magnitude of ir sensor
	return time_constant * (magnitude - wanted_magnitude);
}

void autonomous ()
{
	int magnitude, direction = 0;

	//center the robot on the signal
	while(direction != 5) {
		ir(&magnitude, &direction);

		if (direction == 0) { //if you don't see the beacon, you're done
			break;
		}

		if (direction < 5) { //sensor is to the left
			//move sideways
			motor[centerMotor] = 30;
			wait1Msec(100);
			motor[centerMotor] = 0;

			//turn right
			motor[frontLeftMotor] = -10;
			motor[frontRightMotor] = 10;
			motor[backLeftMotor] = -10;
			motor[backRightMotor] = 10;
			wait1Msec(100);
			motor[frontLeftMotor] = 0;
			motor[frontRightMotor] = 0;
			motor[backLeftMotor] = 0;
			motor[backRightMotor] = 0;

		}	else if (direction > 5) { //sensor is to the right
			//move right
			motor[centerMotor] = -30;
			wait1Msec(100);
			motor[centerMotor] = 0;


			motor[frontLeftMotor] = -10;
			motor[frontRightMotor] = 10;
			motor[backLeftMotor] = -10;
			motor[backRightMotor] = 10;
			wait1Msec(100);
			motor[frontLeftMotor] = 0;
			motor[frontRightMotor] = 0;
			motor[backLeftMotor] = 0;
			motor[backRightMotor] = 0;
		}
	}
	//finish centering goal

	//approach goal after centered
	motor[frontLeftMotor] = 50;
	motor[frontRightMotor] = 50;
	motor[backLeftMotor] = 50;
	motor[backRightMotor] = 50;
	wait1Msec(magnitude_to_time(magnitude));
	motor[frontLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[backRightMotor] = 0;
	//finish approach goal after centered

	//drop into center goals
	motor[drawerMotor] = 50;
	wait1Msec(1000);
	motor[drawerMotor] = 0;

	;
	wait1Msec(1000);
	servo[clickerServo] = servoPosition3;
	//end drop into center goals

	//drive into kickstand here
	motor[centerMotor] = 30;
	wait1Msec(250);
	motor[centerMotor] = 0;

	motor[frontLeftMotor] = 50;
	motor[frontRightMotor] = 50;
	motor[backLeftMotor] = 50;
	motor[backRightMotor] = 50;
	wait1Msec(magnitude_to_time(magnitude));
	motor[frontLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[backRightMotor] = 0;
	//end drive into kickstand

	return;
}

task main()
{
	initializeRobot();
	waitForStart();
	autonomous();
}
